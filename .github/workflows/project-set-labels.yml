name: Project Set Labels

on:
  workflow_dispatch:

jobs:
  sync-status-labels:
    runs-on: ubuntu-latest
    steps:
      - name: Sync project status to issue labels (all repos)
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PAT }}
          script: |
            const STATUS_LABELS = ['Backlog', 'Accepted', 'To do', 'In progress', 'Done', 'Pre-release', 'Release'];
            const labelColors = {
              'Backlog':      '0e8a16',
              'Accepted':     '0075ca',
              'To do':        '0075ca',
              'In progress':  'fbca04',
              'Done':         'e4681e',
              'Pre-release':  'e99695',
              'Release':      '5319e7',
            };
            const owner = context.repo.owner;

            // Find the project at organization level
            const projectsResult = await github.graphql(`
              query($owner: String!) {
                organization(login: $owner) {
                  projectsV2(first: 10) {
                    nodes { id title }
                  }
                }
              }
            `, { owner });

            const projects = projectsResult.organization.projectsV2.nodes;
            if (!projects.length) {
              core.warning('No project found for this organization.');
              return;
            }
            const project = projects[0];
            core.info(`Project used: ${project.title} (${project.id})`);

            // Get all items from the project with their status and repo
            let allItems = [];
            let cursor = null;
            let hasNextPage = true;
            while (hasNextPage) {
              const result = await github.graphql(`
                query($projectId: ID!, $cursor: String) {
                  node(id: $projectId) {
                    ... on ProjectV2 {
                      items(first: 100, after: $cursor) {
                        pageInfo { hasNextPage endCursor }
                        nodes {
                          content {
                            ... on Issue {
                              number
                              repository { name owner { login } }
                            }
                          }
                          fieldValues(first: 20) {
                            nodes {
                              ... on ProjectV2ItemFieldSingleSelectValue {
                                name
                                field { ... on ProjectV2SingleSelectField { name } }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              `, { projectId: project.id, cursor });
              const items = result.node.items;
              allItems = allItems.concat(items.nodes);
              hasNextPage = items.pageInfo.hasNextPage;
              cursor = items.pageInfo.endCursor;
            }

            // Cache for repos already processed
            const checkedRepos = new Set();

            for (const item of allItems) {
              if (!item.content || item.content.number == null) {
                core.warning(`Item ignored (content null) â€” probably a private repo inaccessible with the current PAT.`);
                continue;
              }
              const issueNumber = item.content.number;
              const repo = item.content.repository.name;
              const repoOwner = item.content.repository.owner.login;

              const statusField = item.fieldValues.nodes.find(fv => fv.field && fv.field.name === 'Status');
              const status = statusField?.name;
              if (!status || !STATUS_LABELS.includes(status)) {
                core.info(`${repoOwner}/${repo}#${issueNumber} : status "${status}" ignored.`);
                continue;
              }

              // Delete all status labels and recreate them (once per repo)
              const repoKey = `${repoOwner}/${repo}`;
              if (!checkedRepos.has(repoKey)) {
                checkedRepos.add(repoKey);
                const existingLabels = await github.paginate(github.rest.issues.listLabelsForRepo, { owner: repoOwner, repo });
                const existingLabelNames = existingLabels.map(l => l.name);

                // Delete all status labels
                for (const label of STATUS_LABELS) {
                  if (existingLabelNames.includes(label)) {
                    await github.rest.issues.deleteLabel({ owner: repoOwner, repo, name: label });
                    core.info(`Label deleted in ${repoKey}: ${label}`);
                  }
                }

                // Recreate all status labels
                for (const label of STATUS_LABELS) {
                  await github.rest.issues.createLabel({ owner: repoOwner, repo, name: label, color: labelColors[label] || 'ededed' });
                  core.info(`Label created in ${repoKey}: ${label}`);
                }
              }

              // Apply the status label to the issue, keeping other labels
              const issue = await github.rest.issues.get({ owner: repoOwner, repo, issue_number: issueNumber });
              const currentLabels = issue.data.labels.map(l => l.name);
              const newLabels = [...currentLabels.filter(l => !STATUS_LABELS.includes(l)), status];
              await github.rest.issues.setLabels({ owner: repoOwner, repo, issue_number: issueNumber, labels: newLabels });
              core.info(`${repoKey}#${issueNumber} : label "${status}" applied.`);
            }